---
date: 13.10.2023
tags:
  - theory
  - operational_systems
---
Суть **синхронизации процессов** состоит в согласовании их скоростей путем приостановки процесса до наступления некоторого события и последующей его активизации при наступлении этого события.

Синхронизация лежит в основе любого взаимодействия процессов, которое может быть связано:
- с обменом данными
- с разделением ресурсов
- с синхронизацией процесса с внешними событиями

# Проблемы синхронизации
**Гонками** называются ситуации, когда в отсутствие синхронизации два (или более) процесса обрабатывают разделяемые данные и конечный результат зависит от соотношения скоростей процессов.

**Тупики** - это взаимные блокировки процессов, могущие возникать вследствие недостаточно корректного решения задачи синхронизации и состоящие в том, что ряд процессов удерживает ресурсы, запрашиваемые другими процессами, и в то же время запрашивает ресурсы, удерживаемые другими.

![[IMG20231013112635.jpg]]
![[IMG20231020101503.jpg]]

# Критическая секция
**Критическая секция** - часть программы, в которой осуществляется доступ к разделяемым данным.

Эти данные называется **критическими данными**.

В общем случае в разных потоках критическая секция состоит из разных последовательностей команд.

Чтобы исключить эффект гонок по отношению к некоторому ресурсу, необходимо обеспечить, чтобы в момент в критической секции, связанной с этим ресурсом, находился максимум один процесс. Этот прием называют **взаимным исключением.**

# Средства синхронизации процессов и потоков
Для синхронизации процессов, порождаемых прикладными программами, программист может использовать как собственные средства и приемы, так и средства операционной системы, предоставляемые в форме системных вызовов. Последние являются во многих случаях более эффективными или единственно возможными.

## Метод 1. Запрещать все системные вызовы
Простейший способ обеспечить взаимное исключение **позволить** процессу, находящемуся в критической секции, **запрещать все системные вызовы**.

**Недостатки метода.** Опасно доверять управление системой пользовательскому, процессу, он может надолго занять процессор, а при крахе процесса в критической области крах потерпит вся система, потому что системные вызовы никогда не будут разрешены.

## Метод 2. Использовать блокирующие переменные
Использование блокирующих переменных. С каждым разделяемым ресурсом D связывается двоичная переменная F(D) которая принимает следующие значения:
$$F(D)=\begin{cases}1,\;\text{если ресурс свободен (то есть ни один процесс не}\\ \quad\text{находится в данный момент в критической секции,}\\\quad \text{связанной с данным процессом)};\\
0,\;\text{если ресурс занят.}
\end{cases}$$

**Недостатки метода**. В течение времени, когда один процесс находится в критической секции, другой процесс, которому требуется тот же ресурс, будет выполнять рутинные действия по опросу блокирующей переменной, бесполезно тратя процессорное время.

**Специфика метода.** Если объем работы в критической секции небольшой и вероятность в скором доступе к ресурсу велика, то экономнее окажется метод блокирующих переменных.
### Реализация
- Перед входом в критическую секцию процесс проверяет свободен ли ресурс D.
- Если он занят, (F(D)= 0), то проверка циклически повторяется
- Если же ресурс свободен (F(D) = 1), то значение переменной F(D) устанавливается в 0 и процесс входит в критическую секцию.
- После того как процесс выполнит все действия с разделяемым ресурсом D, значение переменной F(D) снова устанавливается равным 1.

![[IMG20231020103432.jpg|350]]

### Реализация в Windows
Поток, претендующий на доступ к критическим данным для входа в критическую секцию Выполняет системный вызов EnterCriticalSection. B рамках этого вызова выполняется проверка блокирующей переменной. В случае занятости ресурса поток переводится в состояние ожидания и делается отметка о том, что он должен быть активизирован по освобождении ресурса (поток ставится в очередь ожидающих освобождения ресурса). Если ресурс свободен, он занимается (F(D) = 0), делается отметка о его принадлежности данному потоку и поток продолжает работу

Поток, который использует ресурс, после выхода из критической секции должен выполнить системный вызов LeaveCriticalSection. B результате отмечается, что ресурс свободен (F(D) = 1), и первый поток из очереди ожидающих ресурс переводится в состояние готовности.

![[IMG20231020103852.jpg]]

## Семафор Дейкстры
Вводится два новых примитива. В абстрактной форме эти примитивы, традиционно обозначаемые P и V, оперируют над целыми неотрицательными переменными, называемыми семафорами. Пусть S - такой семафор. Операции определяются следующим образом. 

V(S): переменная S увеличивается на 1 одним неделимым действием; выборка, инкремент и запоминание не могут быть прерваны, и к S нет доступа другим процессам во время выполнения этой операции.

P(S): уменьшение S на 1, если это возможно. Если S=0, то невозможно уменьшить S и остаться в области целых неотрицательных значений. В этом случае процесс, вызывающий P-операцию, ждет, пока это уменьшение станет возможным. Успешная проверка и уменьшение также является неделимой операцией.

В частном случае, когда семафор S может принимать только значения 0 и 1, он превращается в блокирующую переменную. Операция P заключает в себе потенциальную возможность перехода процесса, который ее выполняет в состояние ожидания, в то время как V-операция может при некоторых обстоятельствах активизировать другой процесс, приостановленный операцией P.

![[IMG20231020105753.jpg]]

### Тупик
Если переставить местами операции и P(e) и P(b) в программе-писателе, то при некотором стечении обстоятельств рассматриваемые два процесса могут заблокировать друг друга.

Пусть процесс-писатель первым войдет в критическую секцию и обнаружит отсутствие свободных буферов Картина примет следующий вид.
![[IMG20231020110731.jpg|400]]

Писатель ждет освобождения буфера а читатель не может этого сделать, так как эти действие выполняются в ставшей недоступной критической секции.

#### Решение
Решение проблемы тупиков требует решения следующих задач:
- предотвращение тупиков
- распознавание тупиков
- восстановление системы после тупиков

## Монитор
**Монитор** - это набор процедур, переменных и структур данных. Процессы могут вызывать процедуры монитора, но не имеют доступа к внутренним данным монитора. Мониторы имеют важное свойство, которое делает их полезными для достижения взаимного исключения:
- **только один процесс может быть активным по отношению к монитору**

Компилятор обрабатывает вызовы процедур монитора особым образом. Обычно, когда процесс вызывает процедуру монитора, то первые несколько инструкций этой процедуры проверяют, не активен ли какой-либо другой процесс по отношению к этому монитору. Если да, то вызывающий процесс приостанавливается, пока другой процесс не освободит монитор. Таким образом, исключение входа нескольких процессов в монитор реализуется не программистом, а компилятором, что делает ошибки менее вероятными.

## Мьютексы
**Мьютекс** - синхронизирующий объект как для процессов, так и для потоков. В каждый момент времени только один процесс (поток) имеет право обладания этим объектом. 

Пусть два (или более) процесса (потока) имеют необходимость в доступе к некоторому разделяемому ресурсу. Для организации взаимного исключения один из этих процессов должен посредством функции `CreateMytex` создать мьютекс с некоторым именем, предназначенный для пользования этим ресурсом. Остальные процессы должны знать это имя для обращения к мьютексу.

Первым занимает мьютекс либо его создатель, либо процесс, первым вызвавший одну из функций ожидания. По завершении работы с разделяемым ресурсом мьютекс освобождается.

## События
**События** обычно используются для оповещения процессов в завершении некоторых действий. В каждой ОС реализованы свои механизмы передачи сообщений и обработки событий.

В ОС семейства WinNT для передачи данных чаще всего употребляются сообщения. Информация - сама функция и параметры `wparam` и `lparam`.

В UNIX для передачи данных используются конвейеры, каналы, сигналы, а также средства, базирующиеся на протоколе ТСР/ІР.