---
date: 04.10.2023
tags:
  - theory
  - databases
---
# Клиент-серверная архитектура
Клиент начинает общение с сервером.
"Язык" общения сервера с клиентом - протокол.
![[Drawing 2023-10-04 09.56.20.excalidraw|250]]
Сервер должен ответить клиенту за определенный отрезок времени, называемый таймаутом. Превышение таймаута называется отказом в обслуживании (DoS).

Сервер может являться клиентом по отношению к другому серверу.

Одной из первых СУБД была DBASE. Она могла использоваться на персональных компьютерах.
Позже PARADOX, MS Access.
Перечисленные - "однопользовательские" БД.

DBASE использовала файлы расширения `.dbf`. Это расширение используется и сейчас. MS Access использовала(ует) `.mdb`.

От системы "файл-сервер", в которой работа с данными производилась на клиентской стороне (и все данные отправлялись клиенту) перешли к системе "клиент-сервер" (другое понятие), в которой на сервере стоит программа СУБД, а клиенты обращаются к серверу с запросами.
- [p] разгружена сеть (вместо всех данных пересылаются запросы и результаты)
- [p] контроль за ограничениями БД
- [p] контроль доступа к данным
- [p] стандарт SQL -> независимость от формата БД
- вычисления перенесены на сервер

# SQL (Structured Query Language)
Реляционно полный (можно произвести любую реляционную операцию).
Не реляционно эквивалентный (нельзя перевести в реляционное выражение).
Язык 4го поколения (похож на обычный человеческий язык).
Обладает свойствами функционального языка.

Операторы образуют три группы
- DDL (Data Definition Language)
  - `create` - создание
  - `alter` - изменение
  - `drop` - удаление
- DML (Data Manipulation Language)
  - `values` - задание строки
    ```sql
	values(10000, 'K.01', '01.01.2023', '01.02.2023')
    ```
  - `select` - запрос данных
    Можно реализовать все операции реляционной алгебры.
    Возвращает набор данных.
  - `insert` - добавление (набора) записей
  - `update` - изменение значений атрибутов в наборе записей
  - `delete` - удаление (набора) записей
  - `truncate` - удаление (набора) записей (другой алгоритм)
- DCL (Data Control Language)
  - `grant` - предоставление прав доступа
  - `revoke` - отзыв прав доступа

Все операторы SQL поддерживают транзакции (либо операция выполняется полностью, либо не выполняется).

Стандарты SQL нечеткие. Возникает понятие "диалекта" SQL.

Трехзвенная архитектура
Клиентская часть приложения - Серверная часть приложения - СУБД
Они же фронтэнд - бэкэнд.

DB-aware app - приложение, которое "в курсе" о данных и использует все возможности данной СУБД.

- Oracle
- DB2 (IBM)
- MS SQL Server (Microsoft)
- Postgre SQL (open-source)
- MySQL
- MariaDB

LAMP - Linux Apache MySQL PHP
XAMPP - X(Любая ОС) Apache MySQL PHP Perl

БД содержит объекты:
- tables - таблицы
- view - временная, производная таблица
- indexes
- schemata
- SP (stored procedures) - доп. возможности для оптимизации запросов (циклы, условия)
- UDF (user-defined functions)
- roles - ограничения доступа
- nicknames
- aliases

# СУБД
СУБД - программа, которая поддерживает жизненный цикл объектов БД.
РСУБД (реляционная СУБД) = SQL server

Основные функции СУБД:
- Хранение данных. При этом не важно, как она это делает.
- Обслуживание клиентов, выполняя SQL-запросы.
- Обеспечение разграничения доступа к данным.
- Поддержание ограничений ссылочной целостности.
- Обеспечение отказоустойчивости.

Свойства ACID:
- Atomicity - атомарность
- Consistency - целостность
- Isolation - изолированность
- Durability - нестираемость
  Трактуется по-разному:
  - обратимость изменений, если транзакция не успешна
  - по завершении транзакции ее результаты необратимы и видны всем конкурирующим транзакциям

`commit` - принятие изменений
`rollback` - откат изменений, отказ коммита
Обычно все транзакции записываются (ведется log). По завершении транзакции ее лог стирается.
`rollforward` - повторение выполненных и logированных транзакций (обычно при восстановлении с резервной копии).

Аномалии, возникающие при конкурентном доступе
- Чтение неподтвержденных данных (Uncommitted Read - UR)
  Чтение до commit'а, rollback прочитанных данных
- Не повторяющееся чтение (Non-Repeatable Read - NR)
  Изменение данных во время выполнения транзакции, использующей эти данные.
- Чтение фантомов (Phantom Reads - PR)
  Добавление записей в подмножество во время работы транзакции.

Защита от аномалий - блокировка данных
- S(shared)-блокировка
  Позволяет чтение, запрещает изменение
- X(eXclusive)-блокировка
  Запрещает любые операции над данными

Уровни изоляции транзакции (IBM-терминология)
1. RU - read uncommitted
   Позволяет транзакции читать неподтвержденные данные.
   Используется в системах, где транзакции не изменяют данные.
2. CS - cursor stability
   На все записи, с которыми ведется работа накладывается S-блокировка, а на изменяемые - X-блокировка.
3. RS - read stability
4. RR - repeatable read

Эскалация блокировки - вместо блокировки отдельных записей, блокируется вся таблица (например, если блокируется 80% записей, легче блокировать таблицу).

Dead lock - блокировка двумя программами взаимонеобходимых ресурсов ($T_{1}$ занял ресурс A и требует ресурс B, $T_{2}$ занял ресурс B и требует ресурс A).

Проводят проверку после изменения таблицы, выполняют заданную команду при соблюдении.

## Ограничения, задаваемые в БД
Цель ограничений - обеспечить соответствие данных предметной области.

Уровень, на котором можно наложить ограничения.
- уровень строки
  Проверочное ограничение (check constraint)
  Предикат, который определен от атрибутов таблицы.
- уровень таблицы
  Пример - ограничение уникальности.
  Определяются при помощи триггеров.
- уровень нескольких таблиц
  Пример - ограничение ссылочной целостности. Задается при создании дочерней таблицы или изменении ее структуры.

## Производные таблицы
Производные таблицы, запросы(MS), представления, просмотры - VIEW


> [!example] 
> Задача - вывести самые распространенные заболевания
> Простой (неправильный) способ:
> ```sql
> SELECT diagnosis_id, count(*)
> FROM medical.events
> GROUP BY diagnosis_id
> ORDER BY 2
> LIMIT 1
>```
> Правильный способ:
>```sql
>CREATE VIEW medical.numcases AS
> SELECT diagnosis_id, count(*) as num
> FROM medical.events
> GROUP BY diagnosis_id
>```
>
>```sql
>CREATE VIEW medical.maxcases AS
>SELECT MAX(num) as num
>FROM medical.numcases
>```
>
>```sql
>SELECT nc.*
>FROM mediacl.maxcases mx
>INNER JOIN medical.numcases nc
>	ON mx.num = nc.num
>```
>На третьем курсе будем составлять подобные запрос одним query.
